1. **B,D** 「ラムダ式」
   デザインパターン：全体の流れからアルゴリズムのみを抽象化し外部で定義すること
   共通の型のインターフェイスを作ることで、アルゴリズムを個別に定義できる。
   全体・インターフェイス（使われる側）・クラス（使う側）の３つが存在
   .
   →関数型インターフェイスには、ラムダ式に置き換えることができる。
   ※関数型インターフェイス：実装が必要なメソッドが一つだけのインターフェイス型変数
   .
   **ラムダ式の宣言**
   `(引数) -> {処理};`
   ・引数宣言は関数型インターフェイスと一致させなければならない
   ・引数のデータ型の指定を省略することができる。
.
2. ~~A,C~~ **B,C** 「ラムダ式の宣言で省略できる部分」
   **構文**
   `関数型インターフェイスの型 変数名 = (引数) -> {処理};`
   ・引数が一つのときは`()`を省略できる。
   ・実行したい処理が一つのときは`{}`も省略できる。
   ・`{}`を省略するときは`return`を記述できない。
.
3. ~~B~~ **C** 「ラムダ式の変数スコープ」
   同じブロック内（ここではメインメソッド）で宣言した変数と
   同じ名前の変数は、ラムダ式内で宣言できない。
.
4. **D** 「ラムダ式からアクセスできる範囲」
   同じブロック内のローカル変数にアクセスすることができる。
   ・実質的に`final`な変数にのみアクセスできる。
      ラムダ式内外に関わらず、値の変更がされていたらコンパイルエラーになる。
.
5. ~~D~~ **A** 「関数型インターフェイス」
   ・`Consumer<T>`：`void accept(T)`,引数を受け取って処理。結果は戻さない。消費者。
   ・`Supplier<T>`：`T get(T)`,何も受け取らずに結果のみ返す。供給者。
   ・`Predicate<T>`：`boolean test(T)`,引数を受け取って、それを評価する（真偽値）。断定。
   ・`Function<T,R>`：`R apply(T)`,引数を受け取り、指定された型`(R)`の結果を返す。処理。
   →以下に条件分岐が続くので、真偽値を返す`Predicate`を用いる。
.
6. ~~A~~ **C**
.
7. ~~A~~ **B**
   `Function<T,R>`の`<T>`は引数の型を、`<R>`は戻り値の型を表している。
.
8. ~~B~~ **A**